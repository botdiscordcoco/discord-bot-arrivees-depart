import discord
from discord.ext import commands
import os
from dotenv import load_dotenv
from datetime import datetime
import asyncio
import logging
from threading import Thread
from flask import Flask
import time
import json

# Configuration du logging s√©curis√©
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Serveur web optimis√© pour uptime
app = Flask('')

# Variables pour le monitoring
start_time = time.time()
ping_count = 0

@app.route('/')
def home():
    return "Bot Discord Arriv√©es/D√©part est en ligne !"

@app.route('/ping')
def ping():
    """Endpoint ultra-rapide pour uptime monitoring"""
    global ping_count
    ping_count += 1
    return {"pong": True, "timestamp": int(time.time()), "ping_count": ping_count}

@app.route('/status')
def status():
    """Endpoint d√©taill√© avec informations compl√®tes"""
    global ping_count
    ping_count += 1
    uptime = int(time.time() - start_time)
    
    # V√©rifier l'√©tat du bot
    bot_status = "online" if bot.is_ready() else "connecting"
    guild_count = len(bot.guilds) if bot.is_ready() else 0
    
    return {
        "status": bot_status,
        "bot": "discord-arrivees-depart", 
        "uptime_seconds": uptime,
        "uptime_formatted": f"{uptime // 3600}h {(uptime % 3600) // 60}m {uptime % 60}s",
        "ping_count": ping_count,
        "guilds": guild_count,
        "timestamp": int(time.time()),
        "user_id": str(bot.user.id) if bot.user else None,
        "latency_ms": round(bot.latency * 1000, 2) if bot.is_ready() else None
    }

@app.route('/health')
def health():
    """V√©rification de sant√© d√©taill√©e"""
    try:
        is_healthy = bot.is_ready() and len(bot.guilds) > 0
        
        response_data = {
            "healthy": is_healthy,
            "bot_ready": bot.is_ready(),
            "guilds_connected": len(bot.guilds) if bot.is_ready() else 0,
            "latency_ms": round(bot.latency * 1000, 2) if bot.is_ready() else None,
            "timestamp": int(time.time()),
            "uptime_seconds": int(time.time() - start_time)
        }
        
        return response_data, 200 if is_healthy else 503
        
    except Exception as e:
        logger.error(f"Health check error: {e}")
        return {"healthy": False, "error": "Health check failed", "timestamp": int(time.time())}, 503

def run_flask():
    port = int(os.environ.get('PORT', 8080))
    # D√©sactiver les logs Flask pour √©viter le spam
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.WARNING)
    
    app.run(host='0.0.0.0', port=port, debug=False)

def keep_alive():
    t = Thread(target=run_flask)
    t.daemon = True
    t.start()

# Charger les variables d'environnement
load_dotenv()

# Configuration S√âCURIS√âE - Jamais de tokens en dur !
TOKEN = os.getenv('DISCORD_TOKEN')
GUILD_ID = os.getenv('GUILD_ID')

# Validation des variables d'environnement
if not TOKEN:
    logger.error("‚ùå ERREUR CRITIQUE: DISCORD_TOKEN non trouv√© dans les variables d'environnement!")
    logger.error("Cr√©ez un fichier .env avec: DISCORD_TOKEN=votre_token_ici")
    exit(1)

if not GUILD_ID:
    logger.error("‚ùå ERREUR CRITIQUE: GUILD_ID non trouv√© dans les variables d'environnement!")
    logger.error("Ajoutez dans .env: GUILD_ID=votre_id_serveur")
    exit(1)

try:
    GUILD_ID = int(GUILD_ID)
except ValueError:
    logger.error("‚ùå ERREUR: GUILD_ID doit √™tre un nombre!")
    exit(1)

# Configuration des intents
intents = discord.Intents.default()
intents.voice_states = True
intents.guilds = True
intents.members = True
intents.message_content = True

# Cr√©er le bot avec configuration s√©curis√©e
bot = commands.Bot(
    command_prefix='!',
    intents=intents,
    help_command=None,  # D√©sactiver la commande help par d√©faut
    max_messages=1000   # Limiter le cache des messages
)

def validate_guild(guild_id):
    """Valide que l'ID du serveur est autoris√©"""
    return guild_id == GUILD_ID

def validate_category(category_name):
    """Valide que la cat√©gorie est autoris√©e"""
    return category_name == "„Äå Salons vocaux „Äç"

def find_text_channel_for_voice(voice_channel):
    """Trouve le salon o√π envoyer les notifications - utilise directement le salon vocal"""
    if not voice_channel or not voice_channel.guild:
        return None
    
    guild = voice_channel.guild
    
    # Validation de s√©curit√©
    if not validate_guild(guild.id):
        logger.warning(f"‚ö†Ô∏è Tentative d'acc√®s depuis un serveur non autoris√©: {guild.id}")
        return None
    
    # V√©rifier que le salon vocal est bien dans la cat√©gorie autoris√©e
    if not voice_channel.category or not validate_category(voice_channel.category.name):
        return None
    
    # V√©rifier que le bot peut envoyer des messages dans ce salon vocal
    if voice_channel.permissions_for(guild.me).send_messages:
        logger.info(f"‚úÖ Utilisation directe du salon vocal: {voice_channel.name} (ID: {voice_channel.id})")
        return voice_channel
    else:
        logger.warning(f"‚ùå Pas de permission d'√©crire dans le salon vocal: {voice_channel.name}")
        return None

@bot.event
async def on_ready():
    """√âv√©nement d√©clench√© quand le bot est pr√™t"""
    logger.info(f'‚úÖ {bot.user} est connect√© et pr√™t!')
    logger.info(f'üìä Serveurs connect√©s: {len(bot.guilds)}')
    logger.info(f'üîó URL du bot: https://discord-bot-arrivees-depart.onrender.com')
    logger.info(f'‚ö° Latence: {round(bot.latency * 1000, 2)}ms')
    
    # Validation de s√©curit√© : v√©rifier qu'on est sur le bon serveur
    guild = bot.get_guild(GUILD_ID)
    if not guild:
        logger.error(f'‚ùå ERREUR S√âCURIT√â: Serveur avec l\'ID {GUILD_ID} non trouv√©!')
        logger.error('Le bot va se d√©connecter pour des raisons de s√©curit√©.')
        await bot.close()
        return
    
    logger.info(f'üéØ Serveur cible trouv√©: {guild.name}')
    logger.info(f'üë• Membres: {guild.member_count}')
    
    # Trouver la cat√©gorie autoris√©e
    voice_category = None
    target_category_name = "„Äå Salons vocaux „Äç"
    
    for category in guild.categories:
        if category.name == target_category_name:
            voice_category = category
            break
    
    if voice_category:
        logger.info(f'‚úÖ Cat√©gorie vocal trouv√©e: "{voice_category.name}"')
        voice_channels_count = len(voice_category.voice_channels)
        logger.info(f'üîä Salons vocaux surveill√©s: {voice_channels_count}')
        
        # Test de connectivit√© (sans envoyer de message public)
        for vc in voice_category.voice_channels:
            can_write = vc.permissions_for(guild.me).send_messages
            status = "‚úÖ" if can_write else "‚ùå"
            logger.info(f'   üîä {vc.name} (ID: {vc.id}) ‚Üí {status} Peut √©crire')
    else:
        logger.warning(f'‚ùå Cat√©gorie "„Äå Salons vocaux „Äç" non trouv√©e !')
    
    # Log des endpoints disponibles
    logger.info("üåê Endpoints disponibles:")
    logger.info("   üìç / ‚Üí Page d'accueil")
    logger.info("   üìç /ping ‚Üí Monitoring rapide")
    logger.info("   üìç /status ‚Üí Statut d√©taill√©")
    logger.info("   üìç /health ‚Üí V√©rification sant√©")

@bot.event
async def on_voice_state_update(member, before, after):
    """√âv√©nement d√©clench√© lors des changements d'√©tat vocal"""
    
    # Validation de s√©curit√©
    if not member or not member.guild:
        return
    
    if not validate_guild(member.guild.id):
        logger.warning(f"‚ö†Ô∏è Tentative d'utilisation depuis un serveur non autoris√©: {member.guild.id}")
        return

    # Ne traiter QUE les salons vocaux de la cat√©gorie autoris√©e
    voice_category_name = "„Äå Salons vocaux „Äç"
    
    # V√©rifier si le changement concerne la cat√©gorie autoris√©e
    is_relevant_change = False
    
    if before.channel and before.channel.category and validate_category(before.channel.category.name):
        is_relevant_change = True
    
    if after.channel and after.channel.category and validate_category(after.channel.category.name):
        is_relevant_change = True
    
    # Si le changement ne concerne pas la cat√©gorie autoris√©e, ignorer
    if not is_relevant_change:
        return
    
    # Sanitize le nom d'utilisateur pour les logs
    safe_username = member.display_name.replace('\n', '').replace('\r', '')[:50]
    
    # Cas 1: Connexion √† un salon vocal autoris√©
    if (before.channel is None and 
        after.channel is not None and 
        after.channel.category and 
        validate_category(after.channel.category.name)):
        
        logger.info(f"üéØ CONNEXION: {safe_username} ‚Üí {after.channel.name}")
        
        # Message simple et s√©curis√©
        try:
            # Escape les caract√®res sp√©ciaux dans le nom d'utilisateur
            safe_display_name = discord.utils.escape_markdown(member.display_name)
            simple_message = f"üîó **{safe_display_name}** a rejoint le salon"
            
            await after.channel.send(simple_message)
            logger.info(f"‚úÖ Message envoy√©: connexion de {safe_username}")
            
        except discord.HTTPException as e:
            logger.error(f"‚ùå Erreur envoi message connexion: {e}")
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©rale connexion: {e}")
    
    # Cas 2: D√©connexion d'un salon vocal autoris√©
    elif (before.channel is not None and 
          before.channel.category and 
          validate_category(before.channel.category.name) and
          after.channel is None):
        
        logger.info(f"üéØ D√âCONNEXION: {safe_username} ‚Üê {before.channel.name}")
        
        try:
            safe_display_name = discord.utils.escape_markdown(member.display_name)
            simple_message = f"‚ùå **{safe_display_name}** a quitt√© le salon"
            
            await before.channel.send(simple_message)
            logger.info(f"‚úÖ Message envoy√©: d√©connexion de {safe_username}")
            
        except discord.HTTPException as e:
            logger.error(f"‚ùå Erreur envoi message d√©connexion: {e}")
        except Exception as e:
            logger.error(f"‚ùå Erreur g√©n√©rale d√©connexion: {e}")
    
    # Cas 3: Changement entre salons vocaux autoris√©s
    elif (before.channel is not None and after.channel is not None and 
          before.channel != after.channel):
        
        logger.info(f"üéØ CHANGEMENT: {safe_username} {before.channel.name} ‚Üí {after.channel.name}")
        
        # Notification de d√©part (si c'√©tait dans un salon autoris√©)
        if (before.channel.category and validate_category(before.channel.category.name)):
            try:
                safe_display_name = discord.utils.escape_markdown(member.display_name)
                safe_channel_name = discord.utils.escape_markdown(after.channel.name)
                leave_message = f"üì§ **{safe_display_name}** est parti vers #{safe_channel_name}"
                
                await before.channel.send(leave_message)
                logger.info(f"‚úÖ Message d√©part envoy√© pour {safe_username}")
                
            except discord.HTTPException as e:
                logger.error(f"‚ùå Erreur envoi message d√©part: {e}")
            except Exception as e:
                logger.error(f"‚ùå Erreur g√©n√©rale d√©part: {e}")
        
        # Notification d'arriv√©e (si c'est dans un salon autoris√©)
        if (after.channel.category and validate_category(after.channel.category.name)):
            try:
                safe_display_name = discord.utils.escape_markdown(member.display_name)
                safe_channel_name = discord.utils.escape_markdown(before.channel.name)
                arrive_message = f"üì• **{safe_display_name}** est arriv√© depuis #{safe_channel_name}"
                
                await after.channel.send(arrive_message)
                logger.info(f"‚úÖ Message arriv√©e envoy√© pour {safe_username}")
                
            except discord.HTTPException as e:
                logger.error(f"‚ùå Erreur envoi message arriv√©e: {e}")
            except Exception as e:
                logger.error(f"‚ùå Erreur g√©n√©rale arriv√©e: {e}")

@bot.command(name='status')
async def status_command(ctx):
    """Commande pour v√©rifier le statut du bot"""
    # Validation de s√©curit√©
    if not validate_guild(ctx.guild.id):
        logger.warning(f"‚ö†Ô∏è Tentative d'utilisation de !status depuis un serveur non autoris√©")
        return
    
    guild = bot.get_guild(GUILD_ID)
    
    # Trouver la cat√©gorie autoris√©e
    voice_category = None
    for category in guild.categories:
        if validate_category(category.name):
            voice_category = category
            break
    
    voice_channels_count = 0
    total_voice_users = 0
    
    if voice_category:
        voice_channels_count = len(voice_category.voice_channels)
        for vc in voice_category.voice_channels:
            total_voice_users += len(vc.members)
    
    # Calculer l'uptime
    uptime_seconds = int(time.time() - start_time)
    uptime_formatted = f"{uptime_seconds // 3600}h {(uptime_seconds % 3600) // 60}m {uptime_seconds % 60}s"
    
    embed = discord.Embed(
        title="üìä Statut du bot Arriv√©es/D√©part",
        color=0x0099ff,
        timestamp=datetime.now()
    )
    embed.add_field(name="ü§ñ Bot", value=f"{bot.user.mention}", inline=True)
    embed.add_field(name="üè† Serveur", value=f"{guild.name}", inline=True)
    embed.add_field(name="üìÅ Cat√©gorie surveill√©e", value="„Äå Salons vocaux „Äç", inline=True)
    embed.add_field(name="üîä Salons vocaux", value=f"{voice_channels_count}", inline=True)
    embed.add_field(name="üë• Utilisateurs en vocal", value=f"{total_voice_users}", inline=True)
    embed.add_field(name="‚ö° Latence", value=f"{round(bot.latency * 1000, 2)}ms", inline=True)
    embed.add_field(name="‚è±Ô∏è Uptime", value=uptime_formatted, inline=True)
    embed.add_field(name="üìä Pings re√ßus", value=f"{ping_count}", inline=True)
    embed.add_field(name="üîí S√©curit√©", value="‚úÖ Activ√©e", inline=True)
    
    embed.add_field(
        name="üåê Endpoints", 
        value="‚Ä¢ [/ping](https://discord-bot-arrivees-depart.onrender.com/ping)\n‚Ä¢ [/status](https://discord-bot-arrivees-depart.onrender.com/status)\n‚Ä¢ [/health](https://discord-bot-arrivees-depart.onrender.com/health)", 
        inline=False
    )
    
    await ctx.send(embed=embed)
    logger.info(f"üìä Commande status ex√©cut√©e par {ctx.author.display_name}")

@bot.command(name='channels')
async def list_channels(ctx):
    """Commande pour lister tous les salons vocaux surveill√©s"""
    # Validation de s√©curit√©
    if not validate_guild(ctx.guild.id):
        logger.warning(f"‚ö†Ô∏è Tentative d'utilisation de !channels depuis un serveur non autoris√©")
        return
    
    guild = bot.get_guild(GUILD_ID)
    
    # Trouver la cat√©gorie autoris√©e
    voice_category = None
    for category in guild.categories:
        if validate_category(category.name):
            voice_category = category
            break
    
    if not voice_category:
        embed = discord.Embed(
            title="‚ùå Erreur",
            description="Cat√©gorie autoris√©e non trouv√©e !",
            color=0xff0000
        )
        await ctx.send(embed=embed)
        return
    
    embed = discord.Embed(
        title="üîä Salons vocaux surveill√©s",
        description=f"Cat√©gorie: **{voice_category.name}**\nMessages s√©curis√©s dans chaque salon vocal",
        color=0x0099ff,
        timestamp=datetime.now()
    )
    
    for vc in voice_category.voice_channels:
        member_count = len(vc.members)
        status = "üü¢" if member_count > 0 else "‚ö´"
        
        can_write = vc.permissions_for(guild.me).send_messages
        chat_status = "‚úÖ Notifications actives" if can_write else "‚ùå Pas de permission"
        
        embed.add_field(
            name=f"{status} {vc.name}",
            value=f"üë• {member_count} membre(s)\nüí¨ {chat_status}",
            inline=True
        )
    
    await ctx.send(embed=embed)
    logger.info(f"üìã Commande channels ex√©cut√©e par {ctx.author.display_name}")

@bot.command(name='uptime')
async def uptime_command(ctx):
    """Commande pour v√©rifier l'uptime et les statistiques"""
    # Validation de s√©curit√©
    if not validate_guild(ctx.guild.id):
        logger.warning(f"‚ö†Ô∏è Tentative d'utilisation de !uptime depuis un serveur non autoris√©")
        return
    
    uptime_seconds = int(time.time() - start_time)
    uptime_formatted = f"{uptime_seconds // 3600}h {(uptime_seconds % 3600) // 60}m {uptime_seconds % 60}s"
    
    embed = discord.Embed(
        title="‚è±Ô∏è Statistiques d'uptime",
        color=0x00ff00,
        timestamp=datetime.now()
    )
    
    embed.add_field(name="üöÄ D√©marrage", value=f"<t:{int(start_time)}:F>", inline=True)
    embed.add_field(name="‚è±Ô∏è Uptime", value=uptime_formatted, inline=True)
    embed.add_field(name="üìä Pings re√ßus", value=f"{ping_count}", inline=True)
    embed.add_field(name="‚ö° Latence", value=f"{round(bot.latency * 1000, 2)}ms", inline=True)
    embed.add_field(name="üîó URL", value="[discord-bot-arrivees-depart.onrender.com](https://discord-bot-arrivees-depart.onrender.com)", inline=True)
    embed.add_field(name="üì° Status", value="[/status endpoint](https://discord-bot-arrivees-depart.onrender.com/status)", inline=True)
    
    await ctx.send(embed=embed)
    logger.info(f"‚è±Ô∏è Commande uptime ex√©cut√©e par {ctx.author.display_name}")

@bot.event
async def on_command_error(ctx, error):
    """Gestion s√©curis√©e des erreurs de commandes"""
    if isinstance(error, commands.CommandNotFound):
        return  # Ignorer les commandes inexistantes
    
    # Log l'erreur sans exposer d'informations sensibles
    logger.error(f"Erreur de commande: {type(error).__name__}")
    
    # Message g√©n√©rique √† l'utilisateur
    if hasattr(ctx, 'send'):
        await ctx.send("‚ùå Une erreur s'est produite lors de l'ex√©cution de la commande.")

@bot.event
async def on_error(event, *args, **kwargs):
    """Gestion s√©curis√©e des erreurs g√©n√©rales"""
    logger.error(f"Erreur dans l'√©v√©nement {event}")

# Point d'entr√©e s√©curis√©
if __name__ == "__main__":
    logger.info("üöÄ D√©marrage du bot s√©curis√© avec optimisations uptime...")
    logger.info("üåê Endpoints configur√©s: /, /ping, /status, /health")
    
    # D√©marrer le serveur web pour Render
    keep_alive()
    
    try:
        bot.run(TOKEN, log_handler=None)  # D√©sactiver les logs Discord par d√©faut
    except discord.LoginFailure:
        logger.error("‚ùå ERREUR CRITIQUE: Token Discord invalide!")
        logger.error("V√©rifiez votre token dans le fichier .env")
    except KeyboardInterrupt:
        logger.info("üõë Arr√™t du bot demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"‚ùå ERREUR CRITIQUE: {e}")
        logger.error("Le bot va s'arr√™ter pour des raisons de s√©curit√©")
